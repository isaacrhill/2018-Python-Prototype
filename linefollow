from wallaby import *
import constants as c
import movement as m

def depth_sensed():
    return(analog(c.depth_sensor)>c.depth_mid)

def BlackRight():
    return(analog(c.right_tophat)>c.right_tophat_bw)
        
def NotBlackRight():
    return(analog(c.right_tophat)<c.right_tophat_bw)
  
def BlackLeft():
    return(analog(c.left_tophat)>c.left_tophat_bw)
     
def NotBlackLeft():
    return(analog(c.left_tophat)<c.left_tophat_bw)
        
def both_lfollow(time): #line follow with both tophats until time is reached
    print "Starting lfollow_right_bstop()"
    sec = seconds() + time
    while seconds() < sec:
        print "Right tophat: %d"%analog(c.right_tophat)
        print "Left tophat: %d"%analog(c.left_tophat)
        if BlackRight() and BlackLeft():
            m.drive(1000)
            m.turn_right()
            print "Both Black"
        elif BlackRight() and NotBlackLeft():
            mav(c.left_motor,1000)
            print "Black right, not black left"
        elif NotBlackRight() and BlackLeft():
            mav(c.right_motor,-1000)
            print "Not black right, yes black left"
        elif NotBlackRight and NotBlackRight():
            mav(c.right_motor,-1000)
            mav(c.left_motor,1000)
            print "Neither black" 
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)
        
def drive_until_line(time): #drive until left tophat senses line or time is reached
    print "Starting drive_until_line()"
    sec = seconds() + time
    while seconds() < sec and analog(c.left_tophat)<c.left_tophat_bw:
        print "Tophat: %d"%analog(c.left_tophat)
        m.drive(time)
    print "Line sensed, stopped driving"
        
def lfollow_right_bstop(time): #line follow with the right tophat until left tophat senses black or time is reached
    print "Starting lfollow_right_bstop()"
    sec = seconds() + time
    while seconds() < sec and analog(c.left_tophat)<c.left_tophat_bw:
        print "Tophat: %d"%analog(c.right_tophat)
        if BlackRight():
            mav(c.right_motor,-1000)
            print "Black"
        elif not BlackRight():
            mav(c.left_motor,1000)
            print "White!"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)

def lfollow_left_bstop(time): #line follow with the left tophat until right tophat senses black or time is reached
    print "Starting lfollow_left_bstop()"
    sec = seconds() + time
    while seconds() < sec and analog(c.right_tophat)<c.right_tophat_bw:
        print "Tophat: %d"%analog(c.left_tophat)
        if  not BlackLeft():
            mav(c.left_motor,1000)
            print "Black"
        elif BlackLeft():
            mav(c.right_motor,-1000)
            print "White!"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)
        
        
def depth_line_follow_right(): #line follow with the right tophat until depth is sensed, no time involved
    print "Starting line_follow_right()"
    while analog(c.depth_sensor)<c.depth_mid:
        print "Tophat: %d"%analog(c.left_tophat)
        print "Depth: %d"%analog(c.depth_sensor)
        if BlackRight():
            mav(c.left_motor,1000)
            print "Black"
        else:
            mav(c.right_motor,-1000)
            print "White"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)
                

def line_follow_right(time): #line follow with the right tophat until depth is sensed or the time is reached
    print "Starting line_follow_right()"
   #while digital(c.bump_sensor)==0:
    sec = seconds() + time
    while seconds() < sec and analog(c.depth_sensor)<c.depth_mid:
        print "Read: %d"%analog(c.right_tophat)
        if BlackRight():
            mav(c.left_motor,1000)
            print "Black"
        elif not BlackRight():
            mav(c.right_motor,-1000)
            print "White!"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)
                
def b_line_follow_right(time): #line follow with the right tophat as long as no depth is sensed or until time is reached
    print "Starting line_follow_right()"
    sec = seconds() + time
    while seconds() < sec and analog(c.left_tophat)<c.left_tophat_bw:
        print "Tophat: %d"%analog(c.left_tophat)
        print "Depth: %d"%analog(c.depth_sensor)
        if analog(c.depth_sensor)>c.depth_mid:
            msleep(100)
        elif BlackRight():
            mav(c.left_motor,1000)
            print "Black"
        elif not BlackRight():
            mav(c.right_motor,-1000)
            print "White!"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)

def b_line_follow_left(time):  #line follow with the left tophat as long as no depth is sensed or until time is reached
    print "Starting line_follow_left()"
    sec = seconds() + time
    while seconds() < sec and analog(c.right_tophat)<c.right_tophat_bw:
        print "Tophat: %d"%analog(c.right_tophat)
        print "Depth: %d"%analog(c.depth_sensor)
        if analog(c.depth_sensor)>c.depth_mid:
            msleep(100)
        elif not BlackLeft():
            mav(c.left_motor,1000)
            print "Black"
        elif BlackLeft():
            mav(c.right_motor,-1000)
            print "White!"
        msleep(30)
        mav(c.left_motor,0)
        mav(c.right_motor,0)

                
def line_follow_left_time(): #line follow with the left tophat until depth is sensed or the time is reached
    print "Starting line_follow_left()"
    sec = seconds() + time
    while seconds() < sec:
        print "Read: %d"%analog(c.left_tophat)
        if BlackLeft():
            mav(c.right_motor,-1000)
            print "Black"
        else:
            mav(c.left_motor,1000)
            print "White"              
        msleep(30)
        mav(c.left_motor,0)      
        mav(c.right_motor,0)       
